using System.Numerics;
using Phantasma.Business.Blockchain;
using Phantasma.Business.Tests.Simulator;
using Phantasma.Business.VM.Utils;
using Phantasma.Core.Cryptography;
using Phantasma.Core.Domain;
using Phantasma.Core.Numerics;
using Phantasma.Core.Types;

using Xunit;

namespace Phantasma.Business.Tests.Blockchain.Exploits;

[Collection("WhenSystemAddressUsedAsSourceInScriptTests")]
public class WhenSystemAddressUsedAsSourceInScript
{
    string sysAddress;
    PhantasmaKeys user;
    PhantasmaKeys owner;
    Nexus nexus;
    NexusSimulator simulator;
    int amountRequested;
    int gas;
    BigInteger initialAmount;
    BigInteger initialFuel;
    BigInteger startBalance;
    StakeReward reward;

    public WhenSystemAddressUsedAsSourceInScript()
    {
        Initialize();
    }
    
    public void Initialize()
    {
        sysAddress = "S3d79FvexQeerRioAY3pGYpNPFx7oJkMV4KazdTHdGDA5iy";
        user = PhantasmaKeys.Generate();
        owner = PhantasmaKeys.Generate();
        amountRequested = 100000000;
        gas = 99999;
        initialAmount = UnitConversion.ToBigInteger(10, DomainSettings.StakingTokenDecimals);
        initialFuel = UnitConversion.ToBigInteger(10, DomainSettings.FuelTokenDecimals);
        reward = new StakeReward(user.Address, Timestamp.Now);
        InitializeSimulator();

        startBalance = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, DomainSettings.StakingTokenSymbol, user.Address);
    }

    protected void InitializeSimulator()
    {
        simulator = new NexusSimulator(owner);
        nexus = simulator.Nexus;
        nexus.SetOracleReader(new OracleSimulator(nexus));
        SetInitialBalance(user.Address);
    }

    protected void SetInitialBalance(Address address)
    {
        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, address, nexus.RootChain, DomainSettings.FuelTokenSymbol, initialFuel);
        simulator.GenerateTransfer(owner, address, nexus.RootChain, DomainSettings.StakingTokenSymbol, initialAmount);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());
    }

    //"Mint Token Should Not Mint Token."
    [Fact()]
    public void MintTokenShouldNotMintToken()
    {
        var balanceBefore = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, DomainSettings.RewardTokenSymbol, user.Address);
        
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, gas)
                .CallInterop("Runtime.MintToken", sysAddress, user.Address, DomainSettings.RewardTokenSymbol, VMObject.FromStruct(reward), new byte[0], 0).
                SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        //Assertions if exception is not used in this circumstance
        var balanceAfter = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, DomainSettings.RewardTokenSymbol, user.Address);
        Assert.NotEqual(balanceAfter - balanceBefore, 1); //  "A token was generated."
        Assert.Equal(balanceBefore, balanceAfter); // "Tokens were generated or lost."
    }

    //"Mint Tokens Should Not Mint Tokens."
    [Fact()]
    public void MintTokensShouldNotMintTokens()
    {
        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, gas)
                .CallInterop("Runtime.MintTokens", sysAddress, user.Address, DomainSettings.StakingTokenSymbol, amountRequested)
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        var endBalance = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, DomainSettings.StakingTokenSymbol, user.Address);
        Assert.NotEqual(startBalance + amountRequested, endBalance); //  "Requested tokens were minted"
        Assert.Equal(startBalance, endBalance); // "Unexpected number of tokens were minted"
    }

    //"Transfer Tokens Should Not Transfer Tokens"
    [Fact()]
    public void TransferTokensShouldNotTransferTokens()
    {
        // This system address is a valid witness
        sysAddress = "S3dGQ4o4tABpRkVugPyCUeAE4oXinNbxF6C1gfkhXQNDDTU";

        var initialBalanceSys = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, DomainSettings.StakingTokenSymbol, Address.FromText(sysAddress));

        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(user.Address, Address.Null, simulator.MinimumFee, gas)
                .CallInterop("Runtime.MintTokens", owner.Address, sysAddress, DomainSettings.StakingTokenSymbol, amountRequested)
                .CallInterop("Runtime.TransferTokens", sysAddress, user.Address, DomainSettings.StakingTokenSymbol, amountRequested)
                .SpendGas(user.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        var endBalance = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, DomainSettings.StakingTokenSymbol, user.Address);
        var endBalanceSys = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, DomainSettings.StakingTokenSymbol, Address.FromText(sysAddress));
        Assert.NotEqual(startBalance + amountRequested, endBalance); //  "Requested tokens were transfered"
        Assert.Equal(startBalance, endBalance); // "Unexpected number of tokens were transferred"
        Assert.Equal(initialBalanceSys, endBalanceSys); //  "Unexpected number of tokens were transferred"
    }
    
}
