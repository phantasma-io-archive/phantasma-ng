using System;
using System.Linq;
using Phantasma.Business.CodeGen.Assembler;
using Phantasma.Business.Tests.Simulator;
using Phantasma.Business.VM.Utils;
using Phantasma.Core.Cryptography;
using Phantasma.Core.Domain;
using Phantasma.Core.Numerics;
using Phantasma.Core.Types;

using Xunit;

namespace Phantasma.Business.Tests.Blockchain.Exploits;

[Collection("Exploits")]
public class Exploits
{
    [Fact]
    public void DuplicateTransferTest()
    {
        var owner = PhantasmaKeys.Generate();

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        var target = PhantasmaKeys.Generate();

        simulator.BeginBlock();
        var tx1 = simulator.GenerateTransfer(owner, target.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, 1);
        var tx2 = simulator.GenerateTransfer(owner, target.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, 1);

        Assert.True(tx1.Hash == tx2.Hash);

        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());
    }

    [Fact]
    public void ChainTransferExploit()
    {
        var owner = PhantasmaKeys.FromWIF("L2LGgkZAdupN2ee8Rs6hpkc65zaGcLbxhbSDGq8oh6umUxxzeW25");

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        var user = PhantasmaKeys.Generate();

        var symbol = DomainSettings.StakingTokenSymbol;

        var chainAddressStr = Base16.Encode(simulator.Nexus.RootChain.Address.ToByteArray());
        var userAddressStr = Base16.Encode(user.Address.ToByteArray());

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.FuelTokenSymbol, 1000000000);
        simulator.GenerateTransfer(owner, user.Address, simulator.Nexus.RootChain, DomainSettings.StakingTokenSymbol, 100000000);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        var chainAddress = simulator.Nexus.RootChain.Address;
        simulator.BeginBlock();
        var tx = simulator.GenerateTransfer(owner, chainAddress, simulator.Nexus.RootChain, symbol, 100000000);
        var block = simulator.EndBlock().FirstOrDefault();
        Assert.True(simulator.LastBlockWasSuccessful());

        var evts = block.GetEventsForTransaction(tx.Hash);
        Assert.True(evts.Any(x => x.Kind == EventKind.TokenReceive && x.Address == chainAddress));

        var token = simulator.Nexus.GetTokenInfo(simulator.Nexus.RootStorage, symbol);

        var initialBalance = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, token, chainAddress);
        Assert.True(initialBalance > 10000);

        string[] scriptString = new string[]
        {
                $"alias r5, $sourceAddress",
                $"alias r6, $targetAddress",
                $"alias r7, $amount",
                $"alias r8, $symbol",

                $"load $amount, 10000",
                $@"load $symbol, ""{symbol}""",

                $"load r11 0x{chainAddressStr}",
                $"push r11",
                $@"extcall ""Address()""",
                $"pop $sourceAddress",

                $"load r11 0x{userAddressStr}",
                $"push r11",
                $@"extcall ""Address()""",
                $"pop $targetAddress",

                $"push $amount",
                $"push $symbol",
                $"push $targetAddress",
                $"push $sourceAddress",
                "extcall \"Runtime.TransferTokens\"",
        };

        var script = AssemblerUtils.BuildScript(scriptString);

        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(user, ProofOfWork.None, () =>
            ScriptUtils.BeginScript().
                AllowGas(user.Address, Address.Null, simulator.MinimumFee, Transaction.DefaultGasLimit).
                EmitRaw(script).
                SpendGas(user.Address).
                EndScript());

        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        var finalBalance = simulator.Nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, token, simulator.Nexus.RootChain.Address);
        Assert.True(initialBalance == finalBalance);
    }

    [Fact]
    public void TestPrintMoneyWithoutPermission()
    {
        var owner = PhantasmaKeys.FromWIF("L2LGgkZAdupN2ee8Rs6hpkc65zaGcLbxhbSDGq8oh6umUxxzeW25");

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;
        nexus.SetOracleReader(new OracleSimulator(nexus));

        var fuelToken = DomainSettings.FuelTokenSymbol;
        var stakingToken = DomainSettings.StakingTokenSymbol;

        //Let A be an address
        var testUserA = PhantasmaKeys.Generate();

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, testUserA.Address, nexus.RootChain, fuelToken, 10000000000);
        simulator.GenerateTransfer(owner, testUserA.Address, nexus.RootChain, stakingToken, 100000000);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        var balanceBefore = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, stakingToken, testUserA.Address);

        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(testUserA, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(testUserA.Address, Address.Null, simulator.MinimumFee, 99999)
                .CallInterop("Runtime.MintTokens", "S3dP2jjf1jUG9nethZBWbnu9a6dFqB7KveTWU7znis6jpDy", testUserA.Address, stakingToken, 100000000).
                SpendGas(testUserA.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        var balanceAfter = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, stakingToken, testUserA.Address);
        Assert.True(balanceAfter == balanceBefore, $"{balanceAfter} == {balanceBefore}");
        Assert.False(balanceAfter == balanceBefore + 100000000);
    }

    public struct crownStruct
    {
        public Address staker;
        public Timestamp date;
    }

    [Fact]
    public void TestPrintCrowns()
    {
        var owner = PhantasmaKeys.FromWIF("L2LGgkZAdupN2ee8Rs6hpkc65zaGcLbxhbSDGq8oh6umUxxzeW25");

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;
        nexus.SetOracleReader(new OracleSimulator(nexus));

        var fuelToken = DomainSettings.FuelTokenSymbol;
        var stakingToken = DomainSettings.StakingTokenSymbol;

        //Let A be an address
        var testUserA = PhantasmaKeys.Generate();

        var crownRom = new crownStruct
        {
            staker = testUserA.Address,
            date = Timestamp.Now
        };

        var crownRam = 1;

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, testUserA.Address, nexus.RootChain, fuelToken, 10000000000);
        simulator.GenerateTransfer(owner, testUserA.Address, nexus.RootChain, stakingToken, 100000000);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        var reward = new StakeReward(testUserA.Address, Timestamp.Now);

        var balanceBefore = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, "CROWN", testUserA.Address);


        simulator.BeginBlock();
        simulator.GenerateCustomTransaction(testUserA, ProofOfWork.Minimal, () =>
            ScriptUtils.BeginScript()
                .AllowGas(testUserA.Address, Address.Null, simulator.MinimumFee, 99999)
                .CallInterop("Runtime.MintToken", "S3d79FvexQeerRioAY3pGYpNPFx7oJkMV4KazdTHdGDA5iy", testUserA.Address, DomainSettings.RewardTokenSymbol, VMObject.FromStruct(reward), new byte[0], 0)
                .SpendGas(testUserA.Address)
                .EndScript());
        simulator.EndBlock();
        Assert.False(simulator.LastBlockWasSuccessful());

        var balanceAfter = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, "CROWN", testUserA.Address);
        Assert.True(balanceAfter == balanceBefore, $"{balanceAfter} != {balanceBefore}");
    }

    [Fact]
    public void TestInfiniteTokenTransfer()
    {
        var owner = PhantasmaKeys.Generate();

        var simulator = new NexusSimulator(owner);
        var nexus = simulator.Nexus;

        simulator.BeginBlock();
        simulator.GenerateToken(owner, "INFI", "infinity token", 0, 8,
            TokenFlags.Fungible | TokenFlags.Transferable | TokenFlags.Divisible);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        var user = PhantasmaKeys.Generate();

        var infiToken = nexus.GetTokenInfo(nexus.RootStorage, "INFI");

        var infiAmount = 1000 * UnitConversion.GetUnitValue(infiToken.Decimals);

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, nexus.RootChain, DomainSettings.FuelTokenSymbol, 100000000);
        simulator.MintTokens(owner, owner.Address, infiToken.Symbol, infiAmount);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        var balance = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, infiToken, owner.Address);
        Assert.True(balance == infiAmount);

        simulator.BeginBlock();
        simulator.GenerateTransfer(owner, user.Address, nexus.RootChain, infiToken.Symbol, infiAmount);
        simulator.EndBlock();
        Assert.True(simulator.LastBlockWasSuccessful());

        balance = nexus.RootChain.GetTokenBalance(simulator.Nexus.RootStorage, infiToken, user.Address);
        Assert.True(balance == infiAmount);
    }
}
